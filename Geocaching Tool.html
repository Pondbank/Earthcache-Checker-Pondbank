<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Geocaching Tools</title>
  <style>
    :root {
      --bg-color: #ffffff;
      --text-color: #222222;
      --textarea-bg: #ffffff;
      --pre-bg: #eeeeee;
      --button-bg: #1976d2;
      --button-text: white;
      --tab-bg: #f0f0f0;
      --tab-active-bg: #1976d2;
      --tab-active-text: white;
      --tab-text: #555555;
    }

    body.dark {
      --bg-color: #121212;
      --text-color: #e0e0e0;
      --textarea-bg: #1e1e1e;
      --pre-bg: #2a2a2a;
      --button-bg: #388e3c; /* Dark mode button color changed to a green tone */
      --button-text: white;
      --tab-bg: #1e1e1e;
      --tab-active-bg: #388e3c; /* Dark mode tab active color */
      --tab-active-text: white;
      --tab-text: #bbb;
    }

    /* Styles to make the page fill the screen */
    html, body {
      margin: 0;
      padding: 0;
      min-height: 100vh; /* Ensures the page takes at least the full viewport height */
      box-sizing: border-box; /* Includes padding and border in the element's total width and height */
    }

    body {
      background-color: var(--bg-color);
      color: var(--text-color);
      font-family: Arial, sans-serif;
      /* Removed max-width and auto margins to allow full width */
      padding: 1em; /* Add some padding around the content */
      line-height: 1.5;
      transition: background-color 0.3s ease, color 0.3s ease;
    }

    /* Dark mode toggle switch styles */
    .theme-switch-wrapper {
        display: flex;
        align-items: center;
        justify-content: flex-end; /* Align to the right */
        margin-bottom: 1em;
        gap: 0.5em; /* Space between label and switch */
        user-select: none;
    }
    .theme-switch {
        display: inline-block;
        height: 24px;
        position: relative;
        width: 48px;
    }
    .theme-switch input {
        display: none;
    }
    .slider {
        background-color: #ccc;
        bottom: 0;
        cursor: pointer;
        left: 0;
        position: absolute;
        right: 0;
        top: 0;
        transition: .4s;
    }
    .slider:before {
        background-color: #fff;
        bottom: 4px;
        content: "";
        height: 16px;
        left: 4px;
        position: absolute;
        transition: .4s;
        width: 16px;
    }
    input:checked + .slider {
        background-color: var(--button-bg); /* Use button color for active switch */
    }
    input:checked + .slider:before {
        transform: translateX(24px);
    }
    .slider.round {
        border-radius: 24px;
    }
    .slider.round:before {
        border-radius: 50%;
    }


    /* Tabs container */
    .tabs {
      display: flex;
      border-bottom: 2px solid #ccc;
      margin-bottom: 1em;
      user-select: none;
      flex-wrap: wrap; /* Allow tabs to wrap on small screens */
    }

    .tab {
      flex: 1;
      padding: 0.75em;
      text-align: center;
      cursor: pointer;
      background-color: var(--tab-bg);
      color: var(--tab-text);
      font-weight: bold;
      border-radius: 6px 6px 0 0;
      border: 1px solid #ccc;
      border-bottom: none;
      transition: background-color 0.3s ease, color 0.3s ease;
      white-space: nowrap; /* Prevent text wrapping in tabs */
      min-width: fit-content; /* Ensure tab doesn't get too small */
    }

    .tab:not(:last-child) {
      margin-right: 4px;
    }
    /* Margin for wrapped tabs on small screens */
    @media (max-width: 600px) {
        .tab {
            margin-bottom: 4px; /* Space out wrapped tabs vertically */
            flex-basis: auto; /* Allow tabs to size based on content */
        }
        .tab:not(:last-child) {
            margin-right: 2px; /* Reduce horizontal margin for wrapped tabs */
        }
    }


    .tab.active {
      background-color: var(--tab-active-bg);
      color: var(--tab-active-text);
      border-color: var(--tab-active-bg);
    }

    /* Common styles for content areas */
    .tab-content {
      display: none;
      border: 1px solid #ccc;
      border-radius: 0 6px 6px 6px;
      padding: 1em;
      background-color: var(--textarea-bg);
      color: var(--text-color);
    }

    .tab-content.active {
      display: block;
    }

    textarea {
      width: 100%;
      height: 200px;
      font-family: monospace;
      font-size: 1rem;
      padding: 0.5em;
      background-color: var(--textarea-bg);
      color: var(--text-color);
      border: 1px solid #ccc;
      border-radius: 4px;
      resize: vertical;
      margin-bottom: 1em;
      transition: background-color 0.3s ease, color 0.3s ease;
    }

    pre {
      background-color: var(--pre-bg);
      padding: 1em;
      white-space: pre-wrap;
      min-height: 180px;
      border-radius: 4px;
      border: 1px solid #ccc;
      font-size: 1rem;
      color: var(--text-color);
      transition: background-color 0.3s ease, color 0.3s ease;
    }

    button {
      padding: 0.6em 1.5em;
      font-size: 1rem;
      border: none;
      border-radius: 4px;
      background-color: var(--button-bg);
      color: var(--button-text);
      cursor: pointer;
      transition: background-color 0.3s ease;
      margin-top: 0.5em;
      margin-right: 0.5em; /* Added for spacing between buttons */
    }

    button:hover {
      opacity: 0.9;
      outline: none;
    }

    label {
      display: inline-block;
      margin-right: 1em;
      margin-top: 0.5em;
      cursor: pointer;
      user-select: none;
      vertical-align: top; /* Align label and input nicely */
    }
    label input {
      margin-left: 0.5em; /* Space between label text and input */
    }

    input[type="checkbox"] {
      margin-right: 0.3em;
      cursor: pointer;
    }

    input[type="text"],
    input[type="number"],
    select { /* Added select to general styling */
        padding: 0.4em;
        border: 1px solid #ccc;
        border-radius: 3px;
        font-size: 0.95rem;
        background-color: var(--textarea-bg); /* Use textarea bg for consistency */
        color: var(--text-color);
    }

    /* Flexbox for side-by-side fieldsets */
    .fieldset-group {
      display: flex;
      flex-wrap: wrap; /* Allow wrapping on smaller screens */
      gap: 1em; /* Space between fieldsets */
      margin-bottom: 1em;
    }

    fieldset {
      border: 1px solid #ccc;
      padding: 0.5em;
      border-radius: 4px;
      flex: 1; /* Allow fieldsets to grow and shrink */
      min-width: 280px; /* Minimum width before wrapping */
      margin: 0; /* Reset margins from previous styling */
    }

    /* New Flexbox container for Cache Owner and Find Number */
    .input-row {
        display: flex;
        flex-wrap: wrap;
        gap: 1em; /* Space between the two input groups */
        margin-bottom: 1em;
    }
    .input-group {
        flex: 1; /* Allows each input group to take equal space */
        min-width: 280px; /* Ensures they don't get too narrow before wrapping */
    }
    .input-group label {
        display: block; /* Make label take full width within its group */
        margin-right: 0; /* Remove right margin from label */
    }
    .input-group input[type="text"],
    .input-group input[type="number"] {
        width: calc(100% - 1em); /* Adjust input width to fill group, accounting for padding */
    }

    /* Flexbox container for buttons */
    .button-group {
        display: flex;
        flex-wrap: wrap;
        gap: 0.5em; /* Space between buttons */
        margin-top: 1em;
        margin-bottom: 1em;
    }
    .button-group button {
        flex: 1; /* Allows buttons to grow and shrink */
        min-width: 150px; /* Minimum width for buttons */
        margin-right: 0; /* Remove individual button margin */
    }

    /* Styles for the combined checker tab */
    .checker-controls {
      display: flex;
      flex-wrap: wrap;
      gap: 1em;
      align-items: center;
      margin-bottom: 1em;
    }
    .checker-controls button {
      flex: 1; /* Button takes available space */
      min-width: 150px; /* Ensure button isn't too small */
      margin: 0; /* Override previous margin */
    }
    .checker-controls select {
      flex: 0 0 auto; /* Don't grow, keep natural size */
      min-width: 120px; /* Ensure dropdown isn't too small */
    }

    /* Responsive */
    @media (max-width: 480px) {
      textarea {
        height: 140px;
        font-size: 1.1rem;
      }

      pre {
        font-size: 1.1rem;
        min-height: 140px;
      }

      /* Buttons and input groups now flex column by default via flex-wrap */
      .button-group button,
      .input-group {
        width: 100%;
        flex: none; /* Remove flex sizing on small screens to ensure full width */
      }
      .button-group button {
        font-size: 1.1rem;
        padding: 0.8em;
        margin-top: 0.8em;
      }

      /* Adjust checker button width for very small screens if necessary */
      .checker-controls button,
      .checker-controls select {
        width: 100%; /* Stack elements vertically */
        flex: none; /* Remove flex sizing for stacking */
      }


      .tabs {
        flex-direction: column;
      }

      .tab {
        margin-bottom: 6px;
        border-radius: 6px;
      }

      label {
        display: block; /* Make labels stack on small screens */
        margin-bottom: 0.5em;
      }
      label input {
        width: calc(100% - 1em); /* Adjust input width */
        margin-left: 0;
        margin-top: 0.3em;
      }
      /* Ensure fieldsets stack on small screens */
      .fieldset-group {
        flex-direction: column;
      }
      fieldset {
        min-width: unset; /* Remove min-width to allow full stacking */
      }
    }
  </style>
</head>
<body>

  <div class="theme-switch-wrapper">
    <label for="darkModeToggle">Dark Mode</label>
    <label class="theme-switch" for="darkModeToggle">
      <input type="checkbox" id="darkModeToggle" />
      <div class="slider round"></div>
    </label>
  </div>

  <div class="tabs" role="tablist" aria-label="Geocaching tools tabs">
    <div class="tab active" role="tab" tabindex="0" aria-selected="true" aria-controls="tab-loggen" id="tab-btn-loggen">Log Generator</div>
    <div class="tab" role="tab" tabindex="-1" aria-selected="false" aria-controls="tab-checker" id="tab-btn-checker">Checker</div>
    <a href="https://www.geocachingtoolbox.com/" target="_blank" class="tab" role="tab" tabindex="-1">Geocaching Toolbox</a>
  </div>

  <section id="tab-loggen" class="tab-content active" role="tabpanel" aria-labelledby="tab-btn-loggen">
    <h2>Geocache Log Generator</h2>

    <div class="input-row">
      <div class="input-group">
        <label>
          Cache Owner:
          <input type="text" id="cacheOwner" placeholder="Cache owner name" />
        </label>
      </div>
      <div class="input-group">
        <label>
          Find Number:
          <input type="number" id="findNumber" value="965" />
        </label>
      </div>
    </div>

    <div class="fieldset-group">
      <fieldset>
        <legend>Log Phrases:</legend>
        <label><input type="checkbox" id="qef" /> QEF (Quick Easy Find)</label>
        <label><input type="checkbox" id="sl" /> SL (Signed Log)</label>
        <label><input type="checkbox" id="tftc" /> TFTC (Thanks for the Cache)</label>
        <label><input type="checkbox" id="tnln" /> TNLN (Took Nothing, Left Nothing)</label>
        <label><input type="checkbox" id="tftal" /> TFTAL (Thanks For The Adventure Lab)</label>
        <label><input type="checkbox" id="tftec" /> TFTEC (Thanks For The Event Cache / EarthCache)</label>
        <br>
        <label><input type="checkbox" id="ftf" /> FTF (First to Find)</label>
        <label><input type="checkbox" id="stf" /> STF (Second to Find)</label>
        <label><input type="checkbox" id="ttf" /> TTF (Third to Find)</label>
      </fieldset>

      <fieldset>
          <legend>Issues Noticed:</legend>
          <label><input type="checkbox" id="logFull" /> Log is full</label>
          <label><input type="checkbox" id="logWet" /> Log is wet</label>
          <label><input type="checkbox" id="missing" /> Cache is missing</label>
          <label><input type="checkbox" id="needsMaintenance" /> Needs maintenance</label>
          <label><input type="checkbox" id="coordsOff" /> Coordinates may be off</label>
      </fieldset>
    </div>

    <div class="button-group">
        <button onclick="incrementFindNumber()">Add Find to Total</button>
        <button onclick="copyGeneratedLog()">Copy Log Text</button>
    </div>

    <h3>Generated Log:</h3>
    <pre id="generatedLog" style="white-space: pre-wrap; min-height: 140px; border: 1px solid #ccc; border-radius: 4px; padding: 1em; background: var(--pre-bg); color: var(--text-color);"></pre>

    <div id="ownerMaintenanceLogContainer" style="display: none;">
      <h3>Owner Maintenance Log:</h3>
      <pre id="ownerMaintenanceLog" style="white-wrap; min-height: 80px; border: 1px solid #ccc; border-radius: 4px; padding: 1em; background: var(--pre-bg); color: var(--text-color);"></pre>
    </div>
  </section>

  <section id="tab-checker" class="tab-content" role="tabpanel" aria-labelledby="tab-btn-checker">
    <h2>Puzzle Checker</h2>
    <textarea id="answersInputChecker" placeholder="Paste your answers here..."></textarea>

    <div class="checker-controls">
      <button onclick="checkSelectedPuzzle()">Check + Copy + Download</button>
      <select id="puzzleSelect">
        <option value="tower">Tower Bridge</option>
        <option value="berk">Berkhamsted Castle</option>
      </select>
    </div>

    <h3>Results:</h3>
    <pre id="resultsChecker"></pre>
  </section>

  <script>
    // Dark Mode Toggle Logic
    const darkModeToggle = document.getElementById('darkModeToggle');
    const body = document.body;

    // Check for saved theme preference or set based on system preference
    const savedTheme = localStorage.getItem('theme');
    if (savedTheme === 'dark') {
      body.classList.add('dark');
      darkModeToggle.checked = true;
    } else if (savedTheme === null && window.matchMedia('(prefers-color-scheme: dark)').matches) {
      // If no saved theme, and system prefers dark, enable dark mode
      body.classList.add('dark');
      darkModeToggle.checked = true;
    }

    darkModeToggle.addEventListener('change', () => {
      if (darkModeToggle.checked) {
        body.classList.add('dark');
        localStorage.setItem('theme', 'dark');
      } else {
        body.classList.remove('dark');
        localStorage.setItem('theme', 'light');
      }
    });

    // Tabs logic
    const tabs = document.querySelectorAll('.tabs .tab'); // Select all tabs within the .tabs container
    const tabContents = document.querySelectorAll('.tab-content');

    tabs.forEach((tab, i) => {
      // Exclude the external link tab from the internal tab switching logic
      if (tab.tagName === 'A' && tab.href === 'https://www.geocachingtoolbox.com/') {
          // This tab handles its own navigation (external link)
          return;
      }

      tab.addEventListener('click', () => {
        // Find the index of the clicked internal tab
        const internalTabs = Array.from(document.querySelectorAll('.tabs .tab:not(a)'));
        const clickedTabIndex = internalTabs.indexOf(tab);
        activateTab(clickedTabIndex);
      });
      tab.addEventListener('keydown', e => {
        // Find the index of the current internal tab
        const internalTabs = Array.from(document.querySelectorAll('.tabs .tab:not(a)'));
        const currentTabIndex = internalTabs.indexOf(tab);

        if (e.key === "ArrowRight") {
          const nextIndex = (currentTabIndex + 1) % internalTabs.length;
          activateTab(nextIndex);
          internalTabs[nextIndex].focus();
        } else if (e.key === "ArrowLeft") {
          const prevIndex = (currentTabIndex - 1 + internalTabs.length) % internalTabs.length;
          activateTab(prevIndex);
          internalTabs[prevIndex].focus();
        }
      });
    });

    function activateTab(index) {
      // Ensure only internal tabs are affected by active state
      const internalTabs = document.querySelectorAll('.tabs .tab:not(a)');
      internalTabs.forEach(t => {
        t.classList.remove('active');
        t.setAttribute('aria-selected', 'false');
        t.tabIndex = -1;
      });
      tabContents.forEach(tc => tc.classList.remove('active'));

      if (internalTabs[index]) { // Check if the index corresponds to an internal tab
        internalTabs[index].classList.add('active');
        internalTabs[index].setAttribute('aria-selected', 'true');
        internalTabs[index].tabIndex = 0;
        tabContents[index].classList.add('active');
      }
    }

    document.addEventListener('DOMContentLoaded', () => {
        // Load find number from localStorage or default
        const findNumberInput = document.getElementById('findNumber');
        const savedFindNumber = localStorage.getItem('lastFindNumber');
        if (savedFindNumber) {
            findNumberInput.value = savedFindNumber;
        } else {
            findNumberInput.value = 965; // Default value
        }

        // Setup for Needs Maintenance automatic selection and disabling
        const needsMaintenanceCheckbox = document.getElementById('needsMaintenance');
        const otherIssueCheckboxes = document.querySelectorAll('#logFull, #logWet, #missing, #coordsOff');

        function updateNeedsMaintenanceStatus() {
            let anyOtherIssueTicked = false;
            otherIssueCheckboxes.forEach(cb => {
                if (cb.checked) {
                    anyOtherIssueTicked = true;
                }
            });
            needsMaintenanceCheckbox.checked = anyOtherIssueTicked;
            // The needsMaintenance checkbox is always disabled for user interaction
            needsMaintenanceCheckbox.disabled = true;
            generateLog(); // Regenerate log to reflect this change
        }

        // Add event listeners to all relevant inputs/checkboxes to trigger updates
        const allLogInputs = document.querySelectorAll(
            '#cacheOwner, #findNumber, ' +
            '#qef, #sl, #tftc, #tnln, #tftal, #tftec, #ftf, #stf, #ttf, ' + // Include FTF/STF/TTF here for time logic
            '#logFull, #logWet, #missing, #coordsOff' // needsMaintenance is excluded as it's controlled
        );
        allLogInputs.forEach(input => {
            if (input.type === 'checkbox') {
                input.addEventListener('change', updateNeedsMaintenanceStatus); // This will also call generateLog
            } else {
                input.addEventListener('input', generateLog);
            }
        });

        // Specific listener for find number to save to local storage
        findNumberInput.addEventListener('input', () => {
            localStorage.setItem('lastFindNumber', findNumberInput.value);
            generateLog();
        });

        // Initial calls on load
        updateNeedsMaintenanceStatus(); // Set initial state of Needs Maintenance and generate log
        generateLog(); // Initial call to generate log with current time
        activateTab(0); // Activate the first tab (Log Generator) on load
    });


    function incrementFindNumber() {
        const findNumberInput = document.getElementById('findNumber');
        let currentFind = parseInt(findNumberInput.value, 10);
        if (isNaN(currentFind)) {
            currentFind = 964; // Fallback if input is empty or invalid
        }
        findNumberInput.value = currentFind + 1;
        localStorage.setItem('lastFindNumber', findNumberInput.value); // Save new find number
        generateLog(); // Regenerate log with new find number
    }

    function copyGeneratedLog() {
        const generatedLogText = document.getElementById('generatedLog').textContent;
        copyToClipboard(generatedLogText);
    }


    // Question sets for solvers
    const questionSets = {
      tower: {
        title: "Tower Bridge Solver",
        requiresOneForGreat: [0, 1, 2, 4],
        questions: [
          { q: "Stone colour?", keywords: ["cream", "white", "light", "grey", "beige"] },
          { q: "Surface feel?", keywords: ["smooth", "rough", "grainy", "coarse"] },
          { q: "Fossil types?", keywords: ["shell", "bivalve", "coral", "fossil", "hole", "line"] },
          { q: "Fossil clues about environment?", keywords: ["marine", "sea", "ocean", "shallow", "warm", "water", "surface"] },
          { q: "Signs of wear?", keywords: ["blackening", "crack", "pit", "worn"] },
          { q: "Causes of weathering?", keywords: ["pollution", "acid rain", "human", "erosion", "weathering", "rain"] },
          { q: "Why Portland Stone for Tower Bridge?", keywords: ["durable", "strong", "local", "appearance", "aesthetic", "maintenance", "weathering"] }
        ]
      },
      berk: {
        title: "Berkhamsted Castle Solver",
        requiresOneForGreat: [0, 1],
        questions: [
          { q: "What type of stone is most visible?", keywords: ["flint", "chalk", "sandstone", "clunch"] },
          { q: "Where does the spring emerge?", keywords: ["ditch", "moat", "bank", "wall", "spring"] },
          { q: "Is the stone natural or transported?", keywords: ["local", "natural", "transported", "imported"] },
          { q: "How does flint form?", keywords: ["silica", "chalk", "sediment", "marine", "biochemical"] },
          { q: "Why is the spring important?", keywords: ["defence", "water", "moat", "supply"] }
        ]
      }
    };

    function checkSelectedPuzzle() {
      const selectedPuzzle = document.getElementById('puzzleSelect').value;
      const input = document.getElementById("answersInputChecker").value;
      const resultsId = "resultsChecker";
      const currentSet = questionSets[selectedPuzzle];

      if (!currentSet) {
        document.getElementById(resultsId).textContent = "Please select a valid puzzle from the dropdown.";
        return;
      }

      const answers = input.toLowerCase().split('\n').map(a => a.trim()).filter(a => a);
      let output = `Checking answers for ${currentSet.title}:\n\n`;
      let correctCount = 0;
      let totalQuestions = currentSet.questions.length;

      currentSet.questions.forEach((qObj, index) => {
        const userAnswer = answers[index] || "";
        const isCorrect = qObj.keywords.some(keyword => userAnswer.includes(keyword));
        output += `Q${index + 1}: ${qObj.q}\nYour Answer: "${userAnswer}"\n`;
        if (isCorrect) {
          output += `Status: âœ… Correct (contains keyword: ${qObj.keywords.find(keyword => userAnswer.includes(keyword))})\n\n`;
          correctCount++;
        } else {
          output += `Status: âŒ Incorrect (expected keywords: ${qObj.keywords.join(', ')}). Consider rephrasing or adding detail.\n\n`;
        }
      });

      output += `\n--- Summary ---\n`;
      output += `You got ${correctCount} out of ${totalQuestions} questions correct.\n`;

      const requiresOneCorrect = currentSet.requiresOneForGreat.every(reqIndex => {
        const userAnswer = answers[reqIndex] || "";
        return currentSet.questions[reqIndex].keywords.some(keyword => userAnswer.includes(keyword));
      });

      if (correctCount === totalQuestions && requiresOneCorrect) {
        output += `Overall: ðŸŽ‰ Excellent! All primary answers are correct.\n`;
      } else if (correctCount >= totalQuestions * 0.7) { // 70% or more correct
        output += `Overall: ðŸ‘ Great job! Most answers are correct.\n`;
      } else if (correctCount >= totalQuestions * 0.5) { // 50% or more correct
        output += `Overall: ðŸ‘Œ Good effort! You're on the right track.\n`;
      } else {
        output += `Overall: ðŸ¤” Keep trying! Review the questions and your answers.\n`;
      }

      document.getElementById(resultsId).textContent = output;
      copyToClipboard(output);
      downloadTextFile(output, `${selectedPuzzle}_solver_results.txt`);
    }

    function copyToClipboard(text) {
      navigator.clipboard.writeText(text).then(() => {
        console.log('Text copied to clipboard!');
      }).catch(err => {
        console.error('Failed to copy text: ', err);
        alert('Failed to copy results to clipboard. Please copy manually.');
      });
    }

    function downloadTextFile(text, filename) {
      const blob = new Blob([text], { type: 'text/plain' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }

    function generateLog() {
      const owner = document.getElementById('cacheOwner').value.trim();
      const findNumber = document.getElementById('findNumber').value.trim();

      const now = new Date(); // Get current date/time
      const daysOfWeek = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"];
      const day = daysOfWeek[now.getDay()]; // Automatically get day
      const date = now.toISOString().split('T')[0]; // Get date in YYYY-MM-DD format
      const timeInput = `${now.getHours().toString().padStart(2, '0')}:${now.getMinutes().toString().padStart(2, '0')}`; // Get current time HH:MM

      const qef = document.getElementById('qef').checked;
      const sl = document.getElementById('sl').checked;
      const tftc = document.getElementById('tftc').checked;
      const tnln = document.getElementById('tnln').checked;
      const tftal = document.getElementById('tftal').checked;
      const tftec = document.getElementById('tftec').checked;

      const ftf = document.getElementById('ftf').checked;
      const stf = document.getElementById('stf').checked;
      const ttf = document.getElementById('ttf').checked;

      const logFull = document.getElementById('logFull').checked;
      const logWet = document.getElementById('logWet').checked;
      const missing = document.getElementById('missing').checked;
      const needsMaintenance = document.getElementById('needsMaintenance').checked;
      const coordsOff = document.getElementById('coordsOff').checked;

      let outputLines = [];

      // Line 1: Thanks to the cache owner
      if (owner) {
        outputLines.push(`Thanks to the cache owner ${owner} for placing this cache`);
      } else {
        outputLines.push("Thanks to the cache owner for placing this cache");
      }

      // Find number, Date, Day
      if (findNumber) {
        outputLines.push(`Find number - ${findNumber}`);
      }
      if (date) {
        const d = new Date(date + 'T00:00:00');
        const options = { year: 'numeric', month: 'long', day: 'numeric' };
        const formattedDate = d.toLocaleDateString(undefined, options);
        outputLines.push(`Date - ${formattedDate}`);
      }
      if (day) {
        outputLines.push(`Day - ${day}`);
      }

      // Time formatting logic: Round to nearest 5 mins unless FTF/STF/TTF is selected
      if (timeInput) {
        let formattedTime = timeInput; // Default to exact time

        // If NONE of FTF, STF, or TTF are selected, apply 5-minute rounding
        if (!ftf && !stf && !ttf) {
          const [hoursStr, minutesStr] = timeInput.split(':');
          let hours = parseInt(hoursStr, 10);
          let minutes = parseInt(minutesStr, 10);

          // Calculate total minutes since midnight
          let totalMinutes = (hours * 60) + minutes;

          // Round to the nearest 5 minutes
          let roundedMinutes = Math.round(totalMinutes / 5) * 5;

          // Convert back to HH:MM format
          hours = Math.floor(roundedMinutes / 60) % 24; // Use modulo 24 to handle 24:00 becoming 00:00
          minutes = roundedMinutes % 60;

          formattedTime = `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}`;
        }
        outputLines.push(`Time - ${formattedTime}:00`);
      }


      // Additional notes - ONLY Phrases (QEF, SL, TFTC etc.)
      let additionalNotesParts = [];
      let phrases = [];
      if (qef) phrases.push("QEF");
      if (sl) phrases.push("SL");
      if (tftc) phrases.push("TFTC");
      if (tnln) phrases.push("TNLN");
      if (tftal) phrases.push("TFTAL");
      if (tftec) phrases.push("TFTEC");

      let findOrderPhrases = [];
      if (ftf) findOrderPhrases.push("FTF");
      if (stf) findOrderPhrases.push("STF");
      if (ttf) findOrderPhrases.push("TTF");

      if (findOrderPhrases.length > 0) {
        phrases.push(findOrderPhrases[0]);
      }

      if (phrases.length > 0) {
        additionalNotesParts.push(phrases.join(', '));
      }

      // Add note if maintenance is needed
      if (needsMaintenance) {
          additionalNotesParts.push("See owner maintenance log");
      }

      // Only add "Additional notes" line if there are actual phrases or a maintenance note
      if (additionalNotesParts.length > 0) {
        outputLines.push(`Additional notes - ${additionalNotesParts.join(' - ')}`);
      }


      // --- Owner Maintenance Log Generation ---
      // This array will hold all issues that need to be reported to the owner
      let issuesForOwnerLog = [];

      // Handle combined "Log is wet" and "Log is full" for owner log
      if (logWet && logFull) {
        issuesForOwnerLog.push("Logbook is wet and full");
      } else {
        if (logWet) {
            issuesForOwnerLog.push("Logbook is wet");
        }
        if (logFull) {
            issuesForOwnerLog.push("Logbook is full");
        }
      }

      if (missing) {
          issuesForOwnerLog.push("Cache is missing");
      }
      if (coordsOff) {
          issuesForOwnerLog.push("Coordinates may be off");
      }

      // If 'Needs maintenance' is checked (either manually or automatically by other issues)
      // AND no specific issues were identified for the owner (meaning it was a generic 'Needs maintenance' click),
      // then add a generic message to the owner log.
      if (needsMaintenance && issuesForOwnerLog.length === 0) {
          issuesForOwnerLog.push("Maintenance is required for an unspecified reason.");
      }


      // Generate the final output for the main log (filtering out any blank lines that might occur)
      const finalOutput = outputLines.filter(line => line.trim() !== "").join('\n');
      document.getElementById('generatedLog').textContent = finalOutput;

      // Provide a placeholder if the generated log is completely empty
      if (!finalOutput.trim()) {
          document.getElementById('generatedLog').textContent = "Please fill in some details to generate a log.";
      }

      // Control visibility and content of the Owner Maintenance Log
      const ownerLogContainer = document.getElementById('ownerMaintenanceLogContainer');
      const ownerLogElement = document.getElementById('ownerMaintenanceLog');

      // Display owner log only if 'Needs maintenance' is true AND there are actual issues to report (or a generic reason)
      if (needsMaintenance && issuesForOwnerLog.length > 0) {
          let ownerLogContent = issuesForOwnerLog.map(issue => `- ${issue}`).join('\n');
          ownerLogElement.textContent = ownerLogContent;
          ownerLogContainer.style.display = 'block'; // Show the container
      } else {
          ownerLogElement.textContent = '';
          ownerLogContainer.style.display = 'none'; // Hide if no maintenance needed or no issues to report
      }
    }
  </script>
</body>
</html>